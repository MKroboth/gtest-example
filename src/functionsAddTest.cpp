/*
* DO NOT MODIFY THIS COMMENT
* Generated by devmate
* Test model: 25dc4524-b2f7-4ee3-b8b4-1f3c90b57b8a
*/
#define _POSIX_C_SOURCE 200809L

#if __cplusplus < 201402
#error Generated tests require C++14 to run.
#endif

extern "C" {
	#include "functions.h"
}

// Test dependencies

#include <gtest/gtest.h>
#include <tuple>
#include <vector>
#include <algorithm>
#include <functional>

// devmate utils

namespace devmate {
    template<std::size_t SourceSize, std::size_t TargetSize, class ContentType, template<class, std::size_t> class ArrayType = std::array>
    inline void
    initialize_collection(ArrayType<ContentType, SourceSize> const &p_source,
                          ArrayType<ContentType, TargetSize> &p_target) {
        static_assert(SourceSize == TargetSize, "Error: tried to initialize an array with wrong size.");

        std::copy_n(std::begin(p_source), SourceSize, std::begin(p_target));
    }


    template<class MemberType, template<class...> class SourceIterable,
            template<class...> class TargetIterable, class... Rest>
    inline void
    initialize_collection(SourceIterable<MemberType, Rest...> const &p_source,
                          TargetIterable<MemberType, Rest...> &p_target) {
        std::copy(std::begin(p_source), std::end(p_source), std::back_inserter(p_target));
    }

    template<class T>
    constexpr T invalid_value_for() {
        return T{};
    }

    template<>
    constexpr const char *invalid_value_for<const char *>() {
        return "~!invalid value";
    }

    template<typename, typename = void>
    struct has_clear : std::false_type {
    };

    template<typename T>
    struct has_clear<T, std::void_t<decltype(&T::clear)>> : std::is_same<void, decltype(std::declval<T>().clear())> {
    };

    template<class Collection>
    inline std::enable_if_t<has_clear<Collection>::value, void> clear_collection(Collection &collection) {
        collection.clear();
    }

    template<class Other>
    inline std::enable_if_t<!has_clear<Other>::value, void> clear_collection(Other &) {
        // do nothing
    }

    template<class T>
    inline std::enable_if_t<std::is_trivially_copy_assignable<T>::value, void> initialize(T const &source, T &target) {
        target = source;
    }

    template<class MemberType, template<class...> class SourceIterable,
            template<class...> class TargetIterable, class... Rest>

    inline void initialize(SourceIterable<MemberType, Rest...> const &p_source,
                           TargetIterable<MemberType, Rest...> &p_target) {
        clear_collection(p_target);
        initialize_collection(p_source, p_target);
    }

    template<std::size_t SourceSize, std::size_t TargetSize, class ContentType, template<class, std::size_t> class ArrayType = std::array>
    inline void
    initialize(ArrayType<ContentType, SourceSize> const &p_source,
               ArrayType<ContentType, TargetSize> &p_target) {
        initialize_collection(p_source, p_target);
    }

    template<std::size_t Size, class ContentType, template<class, std::size_t> class ArrayType = std::array>
    inline void invalidate_collection(ArrayType<ContentType, Size> &p_array) {
        std::fill_n(std::begin(p_array), Size, invalid_value_for<ContentType>());
    }

    template<class MemberType, template<class...> class Iterable, class... Rest>
    inline void invalidate_collection(Iterable<MemberType, Rest...> &p_iterable) {
        std::fill(std::begin(p_iterable), std::end(p_iterable), invalid_value_for<MemberType>());
    }


    template<class MemberType, template<class...> class Iterable, class... Rest>
    class iterable_size_calculator final {
    public:
        explicit iterable_size_calculator() = default;

        size_t operator()(Iterable<MemberType, Rest...> const &collection) const {
            return std::distance(std::cbegin(collection), std::cend(collection));

        }
    };

    template<class MemberType, class... Rest>
    class iterable_size_calculator<MemberType, std::vector, Rest...> final {
    public:
        explicit iterable_size_calculator() = default;

        size_t operator()(std::vector<MemberType, Rest...> const &collection) const {
            return collection.size();
        }
    };


    template<class MemberType, template<class...> class Iterable, class... Rest>
    inline size_t iterable_size(Iterable<MemberType, Rest...> const &collection) {
        iterable_size_calculator<MemberType, Iterable, Rest...> calculator{};
        return calculator(collection);
    }

    template<class MemberType, size_t Size, template<class, size_t> class ArrayIterable>
    constexpr inline size_t iterable_size(ArrayIterable<MemberType, Size> const &) {
        return Size;
    }

    inline std::function<void(size_t, size_t)>
    equality_length_test(const char *test_unit_name, const char *message = "Invalid length in:") {
        return [=](size_t expected, size_t gotten) {
            ASSERT_EQ(expected, gotten) << message << test_unit_name;
        };
    }

    template<class Container1, class Container2, class Member>
    class _check_collection final {
        Container1 const &container1;
        Container2 const &container2;


    public:
        using member_type = Member;

        explicit _check_collection(Container1 const &p_container1, Container2 const &p_container2) : container1{
                p_container1}, container2{p_container2} {}


        auto check_length(const std::function<void(std::size_t, std::size_t)>& p_length_checker) const -> decltype(*this) {
            auto expected_length = devmate::iterable_size(container1);
            auto result_length = devmate::iterable_size(container2);

            p_length_checker(expected_length, result_length);

            return *this;
        }

        auto
        check_content(std::function<void(Member const &, Member const &)> p_member_checker) const -> decltype(*this) {
            auto expected_length = devmate::iterable_size(container1);
            auto expected_iter = std::cbegin(container1);
            auto result_iter = std::cbegin(container2);

            for (size_t i = expected_length; i--;) {
                p_member_checker(*expected_iter++, *result_iter++);
            }

            return *this;
        }
    };

    template<class Container1, class Container2>
    inline auto
    check_collection(Container1 &&container1, Container2 &&container2) {
        using T1 = typename std::decay<decltype(*std::begin(container1))>::type;
        using T2 = typename std::decay<decltype(*std::begin(container2))>::type;

        static_assert(std::is_same<T1, T2>::value, "both collections must have the same member type");

        return _check_collection<Container1, Container2, T1>{std::forward<Container1>(container1),
                                                             std::forward<Container2>(container2)};
    }

    template<class T>
    std::enable_if_t<!has_clear<T>::value,void> invalidate(T& value) {
        value = invalid_value_for<T>();
    }

    template<class MemberType, template<class...> class Iterable, class... Rest>
    void invalidate(Iterable<MemberType, Rest...>& value) {
        invalidate_collection<MemberType, Iterable, Rest...>(value);
    }
       template<std::size_t Size,class ContentType, template<class, std::size_t> class ArrayType>
               void invalidate(ArrayType<ContentType, Size>& value) {
        invalidate_collection<Size, ContentType, ArrayType>(value);
    }

}		

// User includes

// @generator: let the user add custom includes here

// User configurable types

using test_case_name = const char *;

static void user_init() {
    // insert user specified initialization code
}

static void user_destroy() {
    // insert user specified cleanup code
}

// Unit under test generated types

using parameter_type_0 = int;
using parameter_type_1 = int;
using parameter_type_2 = int;
using parameter_type_3 = test_case_name;

// Test type aliases

template<class ... T>
using parameter_group = std::tuple<T ...>;

using test_parameter = parameter_group<
        int, int, int, test_case_name
>;


// Generated test fixture

#define TEST_SUITE_NAME T25dc4524_add_TestSuite


class TEST_SUITE_NAME : public ::testing::TestWithParam<test_parameter> {
protected:
	parameter_type_0 m_a{devmate::invalid_value_for<parameter_type_0>()};
	parameter_type_1 m_b{devmate::invalid_value_for<parameter_type_1>()};
	parameter_type_2 m_expected{devmate::invalid_value_for<parameter_type_2>()};
	parameter_type_3 m_test_case_name{devmate::invalid_value_for<parameter_type_3>()};
	
	void SetUp() override {
		auto params = GetParam();
		
		devmate::initialize(std::get<0>(params), this->m_a);
		devmate::initialize(std::get<1>(params), this->m_b);
		devmate::initialize(std::get<2>(params), this->m_expected);
		devmate::initialize(std::get<3>(params), this->m_test_case_name);
		
		user_init();
	}

	void TearDown() override {
		
		user_destroy();
		
		// clean/invalidate stored test parameters
		devmate::invalidate(this->m_a);
		devmate::invalidate(this->m_b);
		devmate::invalidate(this->m_expected);
		devmate::invalidate(this->m_test_case_name);
	}
};

TEST_P(TEST_SUITE_NAME, Test_add) {
	auto result = ::add(this->m_a, this->m_b);
	ASSERT_EQ(this->m_expected, result) << "Failed TestCase: " << m_test_case_name;
}


INSTANTIATE_TEST_SUITE_P(Test_add_Instance, TEST_SUITE_NAME, ::testing::Values(
		test_parameter {2, 3, 0, "1 "}
	)
);



/*
WARNING: Modification of this comment will make it impossible to merge user-defined changes

BEGIN_CODEGEN_DATA
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
2itR6gHbPcGB/uiaf4ViVNH1v0lAAA=
END_CODEGEN_DATA
*/
